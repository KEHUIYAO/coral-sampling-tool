import shapely.geometry as sg
import pointpats as pp
import libpysal
import matplotlib
import numpy as np  # NumPy package for arrays, random number generation, etc
import matplotlib.pyplot as plt  # For plotting
import plotly.graph_objects as go
import scipy
from Coral import Coral

import re


class CoralGenerator:
    def __init__(self, area):
        """
        :param area: a sg.Polygon object
        """
        self.area = area
        self.window = self.polygon_to_window(area)
        self.points = None
        self.corals = []

    def polygon_to_window(self, area):
        """
        convert sg.Polygon object to pp.Window object
        :return: pp.Window object
        """
        polygon = []
        for i in list(area.exterior.coords)[::-1]:
            polygon.append(libpysal.cg.shapes.Point(i))
        area = libpysal.cg.Polygon(polygon)
        return pp.Window(area.parts)

    def generate_coral_from_homogeneous_poisson_process(self, disease_prevalence, coral_size, coral_size_sd,
                                                        prop_cover):
        """
        Generate corals within the window which follows the homogeneous poisson process with the intensity rate lambda = number of corals / size of the sampling area
        Give values to self.corals and self.points
        :param disease_prevalence: the proportion of corals which are infected by the disease
        :param coral_size the common size of a coral
        :param coral_size_sd the standard deviation of the coral size
        :param prop_cover: proportion of the area convered by coral within the sampling area

        :return: a list of corals
        """
        # print("Data is generated by a homogeneous poisson process")
        sampling_area_size = self.area.area

        # calculate the total size of coral using the size of sampling area and the cover proportion
        total_coral_size = sampling_area_size * prop_cover
        # print(total_coral_size)

        # since we have the average size of a coral, we can calculate the number of corals in this area
        number_of_corals = np.int(np.floor(total_coral_size / coral_size))
        #print(number_of_corals)
        #print(coral_size)

        # allow for corals with different sizes
        coral_size_new = np.abs(coral_size + coral_size_sd * np.random.randn(number_of_corals))
        coral_size_new = coral_size_new * total_coral_size / np.sum(coral_size_new)
        #print(coral_size_new)

        # calculate the radius of each coral
        coral_radius = np.sqrt(coral_size_new / np.pi)
        #print(coral_radius)

        # generate the health condition of each coral
        coral_health_condition = np.random.binomial(1, disease_prevalence, number_of_corals)

        # set number of realizations = 1, set conditioning = False to use N-conditioned CSR process
        points = pp.PoissonPointProcess(self.window, number_of_corals, samples=1, conditioning=False)

        # extract the realization
        self.points = points.realizations[0]

        # convert the list of Point objects to a list of Coral objects
        for i in range(number_of_corals):
            # the position of each coral
            position = self.points[i]
            self.corals.append(Coral(position[0], position[1], coral_radius[i], coral_health_condition[i]))

        return self.corals

    def generate_coral_from_inhomogeneous_poisson_process(self, disease_prevalence, coral_size, coral_size_sd,
                                                          fun_lambda):
        """
        Generate corals within the window which follows the inhomogeneous poisson process with the intensity function fun_lambda
        Give values to self.corals and self.points
        :param disease_prevalence: the proportion of corals which are infected by the disease
        :param coral_size the common size of a coral
        :param coral_size_sd the standard deviation of the coral size
        :param fun_lambda: intensity rate function lambda(x,y)
        :return: a list of corals
        """
        # Simulation window parameters
        # print("Data is generated by an inhomogeneous poisson process")
        minx, miny, maxx, maxy = self.area.bounds
        xDelta = maxx - minx
        yDelta = maxy - miny  # rectangle dimensions
        areaTotal = self.area.area

        ###START -- find maximum lambda -- START ###
        # For an intensity function lambda, given by function fun_lambda,
        # finds the maximum of lambda in a rectangular region given by
        # [xMin,xMax,yMin,yMax].
        def fun_Neg(x):
            return -fun_lambda(x[0], x[1]);  # negative of lambda

        xy0 = [(minx + maxx) / 2, (miny + maxy) / 2];  # initial value(ie centre)
        # Find largest lambda value
        resultsOpt = scipy.optimize.minimize(fun_Neg, xy0, bounds=((minx, maxx), (miny, maxy)));
        lambdaNegMin = resultsOpt.fun;  # retrieve minimum value found by minimize
        lambdaMax = -lambdaNegMin;

        ###END -- find maximum lambda -- END ###

        # define thinning probability function
        def fun_p(x, y):
            return fun_lambda(x, y) / lambdaMax;

        # Simulate a Poisson point process
        numbPoints = np.random.poisson(lambdaMax * areaTotal);  # Poisson number of points
        xx = np.random.uniform(0, xDelta, ((numbPoints, 1))) + minx;  # x coordinates of Poisson points
        yy = np.random.uniform(0, yDelta, ((numbPoints, 1))) + miny;  # y coordinates of Poisson points

        # calculate spatially-dependent thinning probabilities
        p = fun_p(xx, yy);

        # Generate Bernoulli variables (ie coin flips) for thinning
        booleRetained = np.random.uniform(0, 1, ((numbPoints, 1))) < p;  # points to be thinned

        # x/y locations of retained points
        xxRetained = xx[booleRetained]
        yyRetained = yy[booleRetained]

        # ensure the point is within the sampling region

        self.points = []
        for i in range(len(xxRetained)):
            if self.area.contains(sg.Point(xxRetained[i], yyRetained[i])):
                self.points.append([xxRetained[i], yyRetained[i]])

        number_of_corals = len(self.points)
        self.points = np.array(self.points)

        # allow for corals with different sizes
        coral_size_new = np.abs(coral_size + coral_size_sd * np.random.randn(number_of_corals))

        # calculate the radius of each coral
        coral_radius = np.sqrt(coral_size_new / np.pi)

        # generate the health condition of each coral
        coral_health_condition = np.random.binomial(1, disease_prevalence, number_of_corals)

        for i in range(number_of_corals):
            position = self.points[i]
            self.corals.append(Coral(position[0], position[1], coral_radius[i], coral_health_condition[i]))

        return self.corals

    def generate_coral_from_poisson_cluster_process(self, disease_prevalence, coral_size, coral_size_sd,
                                                    prop_cover, parent_prop, parent_range):

        "generate corals from a poisson cluster process within a region"
        sampling_area_size = self.area.area

        # calculate the total size of coral using the size of sampling area and the cover proportion
        total_coral_size = sampling_area_size * prop_cover

        # since we have the average size of a coral, we can calculate the number of corals in this area
        number_of_corals = np.int(np.floor(total_coral_size / coral_size))

        # number of parent corals
        number_parent_coral = np.int(np.round(number_of_corals * parent_prop))
        # number of children coral for each parent
        number_children_coral_each_parent = np.int(np.round(number_of_corals / number_parent_coral))
        # recalibrate the total number of coral
        number_of_corals = number_parent_coral * number_children_coral_each_parent

        # allow for corals with different sizes
        coral_size_new = np.abs(coral_size + coral_size_sd * np.random.randn(number_of_corals))
        coral_size_new = coral_size_new * total_coral_size / np.sum(coral_size_new)

        # calculate the radius of each coral
        coral_radius = np.sqrt(coral_size_new / np.pi)

        # generate the health condition of each coral
        coral_health_condition = np.random.binomial(1, disease_prevalence, number_of_corals)

        # set number of realizations = 1, set conditioning = False to use N-conditioned CSR process
        points = pp.PoissonClusterPointProcess(self.window, number_of_corals, number_parent_coral, parent_range, 1,
                                               asPP=True, conditioning=False)

        # extract the realization
        self.points = points.realizations[0].df.values

        # convert the list of Point objects to a list of Coral objects

        for i in range(number_of_corals):
            # the position of each coral
            position = self.points[i]
            self.corals.append(Coral(position[0], position[1], coral_radius[i], coral_health_condition[i]))

        return self.corals

    def generate_coral_from_strauss_process(self, disease_prevalence, coral_size, coral_size_sd, strauss_beta,
                                            strauss_gamma, strauss_R):
        """
        generate corals from a strauss process within a region
        :param disease_prevalence: the proportion of corals which are infected by the disease
        :param coral_size the common size of a coral
        :param coral_size_sd the standard deviation of the coral size
        :param strauss_beta: intensity rate
        :param strauss_gamma: contorls the 'strength' of interaction between points, if gamma = 1 the model reduces to a Poisson process. If gamma = 0, the model is a hard core process. For values 0<gamma<1, the process exhibits inhibition between points
        :param strauss_R: pairwise distance

        :return: a list of corals
        """

        # ensure the point is within the sampling region
        points = rStrauss(strauss_beta, strauss_gamma, strauss_R, self.area)
        ind_keep = []
        for i in range(len(points)):
            if self.area.contains(sg.Point(points[i][0], points[i][1])):
                ind_keep.append(i)
        points = points[ind_keep]
        self.points = points
        number_of_corals = len(self.points)

        # allow for corals with different sizes
        coral_size_new = np.abs(coral_size + coral_size_sd * np.random.randn(number_of_corals))

        # calculate the radius of each coral
        coral_radius = np.sqrt(coral_size_new / np.pi)

        # generate the health condition of each coral
        coral_health_condition = np.random.binomial(1, disease_prevalence, number_of_corals)

        for i in range(number_of_corals):
            position = self.points[i]
            self.corals.append(Coral(position[0], position[1], coral_radius[i], coral_health_condition[i]))

        return self.corals
    

    def plot(self, ax = None, window=True, *args, **kwargs):
        "plot the point pattern"
        # point_pattern = pp.PointPattern(self.points)
        # if window:
        #     patches = []
        #     for part in point_pattern.window.parts:
        #         p = matplotlib.patches.Polygon(np.asarray(part))
        #         patches.append(p)
        #     ax.add_collection(matplotlib.collections.PatchCollection(patches, facecolor='w',
        #
        #                                                    edgecolor='k', alpha=0.3))

        # plot a new figure
        if not ax:
            # no ax object pass to the plot, this is the individual plot
            # turn on the flag to output the plot
            fig, ax = plt.subplots()

        # add corals on the exsiting figure
        polygon_region = matplotlib.patches.Polygon(self.area.exterior.coords, color='k', *args, **kwargs)
        ax.add_patch(polygon_region)
        num_color_mapping = {0: 'g', 1: 'r'}
        for i in self.corals:
            i.plot(ax)

        # plot a new figure
        if not ax:
            plt.show()

    def plot_with_plotly(self, dpi=None, *args, **kwargs):
        fig = go.Figure()
        # add boarder
        svg = self.area._repr_svg_()
        pattern = r'.*d="(.*)z.*'
        svg_for_plotly = re.search(pattern, svg).group(1)
        fig.add_shape(type='path', path=svg_for_plotly)
        fig.update_xaxes(range=[self.area.bounds[0], self.area.bounds[2]])
        fig.update_yaxes(range=[self.area.bounds[1], self.area.bounds[3]])
        # add corals in an efficient way
        x = [i.x for i in self.corals]
        y = [i.y for i in self.corals]
        radius = [i.radius for i in self.corals]
        x0 = [x[i]-radius[i] for i in range(len(x))]
        y0 = [y[i]-radius[i] for i in range(len(x))]
        x1 = [x[i]+radius[i] for i in range(len(x))]
        y1 = [y[i]+radius[i] for i in range(len(x))]


        # aliceblue, antiquewhite, aqua, aquamarine, azure,
        # beige, bisque, black, blanchedalmond, blue,
        # blueviolet, brown, burlywood, cadetblue,
        # chartreuse, chocolate, coral, cornflowerblue,
        # cornsilk, crimson, cyan, darkblue, darkcyan,
        # darkgoldenrod, darkgray, darkgrey, darkgreen,
        # darkkhaki, darkmagenta, darkolivegreen, darkorange,
        # darkorchid, darkred, darksalmon, darkseagreen,
        # darkslateblue, darkslategray, darkslategrey,
        # darkturquoise, darkviolet, deeppink, deepskyblue,
        # dimgray, dimgrey, dodgerblue, firebrick,
        # floralwhite, forestgreen, fuchsia, gainsboro,
        # ghostwhite, gold, goldenrod, gray, grey, green,
        # greenyellow, honeydew, hotpink, indianred, indigo,
        # ivory, khaki, lavender, lavenderblush, lawngreen,
        # lemonchiffon, lightblue, lightcoral, lightcyan,
        # lightgoldenrodyellow, lightgray, lightgrey,
        # lightgreen, lightpink, lightsalmon, lightseagreen,
        # lightskyblue, lightslategray, lightslategrey,
        # lightsteelblue, lightyellow, lime, limegreen,
        # linen, magenta, maroon, mediumaquamarine,
        # mediumblue, mediumorchid, mediumpurple,
        # mediumseagreen, mediumslateblue, mediumspringgreen,
        # mediumturquoise, mediumvioletred, midnightblue,
        # mintcream, mistyrose, moccasin, navajowhite, navy,
        # oldlace, olive, olivedrab, orange, orangered,
        # orchid, palegoldenrod, palegreen, paleturquoise,
        # palevioletred, papayawhip, peachpuff, peru, pink,
        # plum, powderblue, purple, red, rosybrown,
        # royalblue, saddlebrown, salmon, sandybrown,
        # seagreen, seashell, sienna, silver, skyblue,
        # slateblue, slategray, slategrey, snow, springgreen,
        # steelblue, tan, teal, thistle, tomato, turquoise,
        # violet, wheat, white, whitesmoke, yellow,
        # yellowgreen

        num_color_mapping = {0:'blue', 1:'red'}
        condition = [num_color_mapping[i.health_condition] for i in self.corals]
        for i in range(len(x)):
            fig.add_shape(type='circle', x0=x0[i], y0=y0[i], x1=x1[i], y1=y1[i], fillcolor=condition[i], opacity=0.5)

        # fig.add_trace(go.Scatter(x=x, y=y, mode='markers', marker=dict(color=condition, opacity=0.5)))
        return fig

if __name__ == "__main__":
    area = sg.Polygon([(0, 0), (0, 100), (100, 100), (100, 0)])
    coral_generator = CoralGenerator(area)
    #coral_generator.generate_coral_from_strauss_process(0.1,0.5,0.1,2,0.2,0.7)
    coral_generator.generate_coral_from_poisson_cluster_process(0.1, 0.5, 0.1, 0.3, 0.1, 5)
    print(coral_generator.corals)
    coral_generator.plot(alpha = 0.1)
